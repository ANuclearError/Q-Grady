\documentclass[report.tex]{subfiles}
\begin{document}

\chapter{System Design} % (fold)
\label{cha:system_design}
% chapter system_design (end)
\section{Q'Grady Language} % (fold)
\label{sec:q_grady_language}
The Q'Grady language is designed to describe the set-up of non-local boxes.
This is achieved through defining the probability distribution of that set-up.
The intent was to focus on providing a clear syntax to represent the
distribution so that the probabilities could be easily identified. 

Original attempts at the language were not up to the same standards in terms of
clarity and simplicity in the language. Listing \ref{pr_qgrady_example} a basic
example of a Q'Grady file.

\lstinputlisting[numbers=left, basicstyle=\ttfamily\footnotesize,
caption={The PR Q'Grady file.}, label=pr_qgrady_example,
frame=single]{files/pr.qgrady} 

When the general style for the language was decided upon, the next step was to
formalise the language, providing a grammar and the semantics of the language,
in order to provide a specification that was easy to understand and work with.

\subsection{Syntax} % (fold)
\label{sub:syntax}
The syntax of the language started with simply the probability matrix seen in
lines 4-9 of Listing \ref{pr_qgrady_example} starting from `['. Each row of
probabilities is separated by a semi-colon while each probability is separated
by a comma instead. It is important to note that for a probability, it must be
the form of a decimal number, and cannot be an integer, so `0' would not be
valid when `0.0' is.

The opposite is true for the range values, which denote how many possible values
the inputs and outputs can have, starting from 0. This allows for the compiler
to ensure that the probability matrix has enough values to cover all instances.
Thus, it is essential that an integer be used here rather than a decimal number.

Line 4 provides the variables that make up the box, with the arrow denoting that
the left hand is the input and the right hand side is the output. This was seen
as an intuitive syntax, while also allowing the square brackets of the matrix to
also act as the curly braces seen in C like syntaxes.

The full BNF of the language in Appendix \ref{sec:q_grady_syntax}. I decided
upon the use of standard BNF rather than using Extended BNF due to the former
style's simplicity \cite[chapter 2.3.4, p.~38]{Watt:1991:PLS:120468}. I felt
more comfortable using the simpler BNF in comparison with the regular expression
similarities extended BNF has.
% subsection syntax (end)

\subsection{Semantics} % (fold)
\label{sec:semantics}
The box is a conditional probability distribution that satisfies non-signalling.
Each row is a list of the probabilities of each outcome based on the given
input. For Listing \ref{pr_qgrady_example}, line 5 would represent 
\(P(ab | 00)\). In order for the box to make sense, the following criteria must
be met (formal semantics are available in Appendix \ref{sec:q_grady_semantics}):
\begin{itemize}
    \item The number of rows in the matrix must equal the input range to the
    power of the number of inputs.
    \item The number of columns must equal the output range to the power of the
    number of outputs.
    \item Each item in the matrix be between 0 and 1.
    \item Each row must sum to 1.
    \item There must be no duplicate variables or use of PRISM keywords.
\end{itemize}

% subsection semantics (end)
% section q_grady_language (end)

\section{Q'Grady Compiler} % (fold)
\label{sec:q_grady_compiler}
The Q'Grady compiler can be divided into five different parts that work
together to create the full software.
\begin{itemize}
    \item The application, going through and controlling the various stages.
    \item A Java class, Box, representing the box, acting as an intermediary
    between the Q'Grady and PRISM files.
    \item The syntax checker, achieved through the use of Cup and JFlex.
    \item The semantics analyser, ensuring that the semantics are met.
    \item The file generator, producing the PRISM file.
\end{itemize}

The flowchart outlined in Fig. \ref{fig:compiler_flowchart} shows the general
structure of the compiler. It goes through the syntax, semantics and file
generation stages until a problem with the input file is found, at which point
it will cease the compilation process and exit the system.

\subsection{Application} % (fold)
\label{sub:application}
The \texttt{Application} class handles the control flow of the compiler,
containing the main method and going through each of the steps outlined in Fig.
\ref{fig:compiler_flowchart}. The class itself is responsible for the source
file location and verification, before passing it through to the parsing and
future steps.
% subsection application (end)

\subsection{Box Class} % (fold)
\label{sub:box_class}
The \texttt{Box} class contains all the information extracted from the Q'Grady
file. The probability distribution, variables and ranges are all stored here. It
also contains the methods for calculating the probabilities of given inputs and
outputs, including the reduced and normalised probabilities required for the
file generation.
% subsection box_class (end)

\subsection{Syntax Checker} % (fold)
\label{sub:syntax_checker}
The syntax checker is made up of files generated by the Cup and JFlex libraries.
It handles the parsing of the input file, ensuring that it matches the grammar
of the language. It also extracts the information from the input file to create
the Box object required for the system.
% subsection syntax_checker (end)

\subsection{Semantics Analyser} % (fold)
\label{sub:semantics_analyser}
The \texttt{SemanticsAnalyser} is a class with static methods for handling the
calculations and measurements required to ensure that the input file is indeed a
valid non-local box. It ensures that the distribution makes sense and that the
box is truly a non-signalling one.
% subsection semantics_analyser (end)

\subsection{File Generator} % (fold)
\label{sub:file_generator}
The file generator are the classes \texttt{FileGenerator} and
\texttt{PrismMacros} that uses the given Box object to create the PRISM model.
The \texttt{PrismMacros} class is a class containing static methods that insert
given variables into pre-defined strings that can make up a PRISM model.
% subsection file_generator (end)

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node (start) [startstop] {Start};
        \node (io1) [io, below of=start] {Get source file location};
        \node (pro1) [process, below of=io1] {Validate source file};
        \node (dec1) [decision, below of=pro1] {Valid?};
        \node (pro2) [process, below of=dec1, yshift=-0.5cm] {Syntax parsing};
        \node (dec2) [decision, below of=pro2] {Valid?};
        \node (pro3) [process, below of=dec2, yshift=-0.5cm] {Semantics Check};
        \node (dec3) [decision, below of=pro3] {Valid?};
        \node (pro4) [process, below of=dec3, yshift=-0.5cm] {Generate file};
        \node (io2) [io, below of=pro4] {Save file};

        \node (stop) [startstop, left of=dec2, xshift=-3cm] {Stop};
        \node (finish) [startstop, below of=io2] {Finished};

        \draw [arrow] (start) -- (io1);
        \draw [arrow] (io1) -- (pro1);
        \draw [arrow] (pro1) -- (dec1);
        \draw [arrow] (dec1) -- node[anchor=east] {yes} (pro2);
        \draw [arrow] (pro2) -- (dec2);
        \draw [arrow] (dec2) -- node[anchor=east] {yes} (pro3);
        \draw [arrow] (pro3) -- (dec3);
        \draw [arrow] (dec3) -- node[anchor=east] {yes} (pro4);
        \draw [arrow] (pro4) -- (io2);

        \draw [arrow] (dec1) -| node[anchor=south] {no} (stop);
        \draw [arrow] (dec2) -- node[anchor=south] {no} (stop);
        \draw [arrow] (dec3) -| node[anchor=north] {no} (stop);
        \draw [arrow] (io2) -- (finish);
    \end{tikzpicture}
    \caption{Flowchart of compiler process} \label{fig:compiler_flowchart}
\end{figure}
% section q_grady_compiler (end)

\newpage
\end{document}