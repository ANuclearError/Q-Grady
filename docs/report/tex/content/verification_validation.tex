\documentclass[report.tex]{subfiles}
\begin{document}

\chapter{Verification and Validation} % (fold)
\label{cha:verification_and_validation}
This chapter outlines the procedures used for the verification and validation of
the language and compiler. Through a mixture of JUnit tests and PRISM testing,
a measure of how fit for purpose Q'Grady is. The verification will outline how
functionally correct the system is, while the validation will outline how it
satisfies the requirements of the system.

% chapter verification_and_validation (end)
\section{Verification} % (fold)
\label{sec:verification}
In relation to the verification of the language and compiler, there are the
following considerations:
\begin{itemize}
    \item Does the compiler recognize bad syntax?
    \item Does the compiler recognize invalid set-ups?
    \item Are the generated models correct?
\end{itemize}

These were the primary criteria that were considered for determining the
usefulness of the system. During the later stages of development, it became
clear that the complexity was not going to reach the levels of what was wanted
from my supervisor and myself, with ideas of multiple boxes interacting with
each being the type of high level goals aimed for. My priorities then became
more realistic in ensuring the quality of the boxes that can be produced.

A more detailed look at the test cases used can be found in Appendix
\ref{cha:detailed_test_strategy_and_test_cases}.

\subsection{Syntax Checking} % (fold)
\label{sub:syntax_checking}
It was important to ensure that the CUP and JFlex files required for the system
were correct, matching the BNF I had created for the language. Testing was
achieved through the creation of bad files to see if the compiler rejected them.
Various mistakes were required, such as the simple missing semi-colon.
% subsection syntax_checking (end)

\subsection{Recognizing Invalid Set-up} % (fold)
\label{sub:recognizing_invalid_set_up}
The recognizing of invalid set-ups is done with the \texttt{SemanticAnalyser}
class, so the testing of that class was of vital importance in ensuring that
the system is able to distinguish correct set-ups from incorrect set-ups. In
particular, the non-signalling property needs tested to ensure that is able to
handle the possible outcomes. Using JUnit, a \texttt{SemanticAnalyerTest} class
was created to handle the test cases that would occur.
% subsection recognizing_invalid_set_up (end)


\subsection{Validating Models} % (fold)
\label{sub:validating_models}
In the PRISM software, there is a feature `Compute Steady State Probabilities'
that can be used to determine whether the generated models match the Q'Grady
file. By dividing each probability in the distribution by the total number of
rows that create the distribution, we can compare it to the steady state
probabilities to determine whether or not the distribution of the input Q'Grady
file has been converted into the equivalent PRISM model.

Naturally, an inaccurate \texttt{FileGenerator} class would also present the
possibility of generating models PRISM could not compile, 
% subsection validating_models (end)
% section verification (end)

\section{Validation} % (fold)
\label{sec:validation}
The original requirements of this project was to create a language for defining
the set-ups of non-local boxes, and the development of a compiler to translate
these set-ups into PRISM models. The language and compiler must ensure that
non-signalling is not violated. The final conclusions of this report will
outline that while the Q'Grady language and compiler can handle boxes with two
outputs of any range, more work would be required to ensure that the compiler
can handle set-ups with three or more outputs.

Another requirement was the production of meaningful error messages to the user.
While the semantics analysis of the input file does produce meaningful error
messages, the syntax checking of the file does not have the same level of
handling.

In relation to non-functional requirements, the User Guide of Appendix
\ref{cha:user_guide} achieves this goal, in providing someone the ability to
create their own boxes without extensive PRISM knowledge. The speed of the
compiler is certainly within reason.
% section validation (end)
\newpage
\end{document}