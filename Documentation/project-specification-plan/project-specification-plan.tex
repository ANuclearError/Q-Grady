\documentclass[11pt, a4paper]{article}
\usepackage[parfill]{parskip}
\setlength\parindent{0pt}

\begin{document}
\title{Q'Grady \\A Compiler for PRiSM \\
\large{Project Specification and Plan}}
\author{Aidan O'Grady - 201218150\\Supervisor: Ross Duncan}
\date{}
\maketitle

\section{Requirements} % (fold)
\label{sec:requirements}

\subsection{Functional Requirements} % (fold)
\label{sub:functional_requirements}
In terms of the Q'Grady language, the functional requirement is to allow for
set-ups of non-local boxes to be defined using that language.

The functional requirements of the Q'Grady compiler are to take the files
created in the Q'Grady language, and after checking that the non-local boxes
defined are non-signalling, will produce an equivalent PRISM file that can
be used for experimentation. If the file is not a valid set-up (syntax errors,
signalling detected), then the system must let the user be aware of this.
% subsection functional_requirements (end)

\subsection{Non-functional Requirements} % (fold)
\label{sub:non_functional_requirements}
Non-functional requirements of the compiler would be features such as allowing
stronger integration with PRISM. For example, it would be convenient for the
user to have PRISM automatically load the created model if the user provides
a flag during compilation.

Another non-functional requirement would be the error handling. The presentation
of errors during compilation, such as invalid syntax should be nicely presented
to the user.
% subsection non_functional_requirements (end)
% section requirements (end)

\newpage
\section{Technologies to be used} % (fold)
\label{sec:technologies_to_be_used}

The following identifies tools that will be used as part of the project. 
Please understand that due to the structure of this project, this is not an
exhaustive list of libraries or tools, since, as the plan shows, the compiler
itself is not being 
% subsection technologies_to_be_used (end)

\subsection{PRISM}
\label{sub:prism}
PRISM is a probabilistic model checker, software used to create formal models
using the PRISM language and allows for analysis of the models created. The
models are created to represent systems with random or probabilistic behaviour.

PRISM has been an essential part of the background study and theory learning
aspect of this project, the first of the three high-level milestones. Work has
been done in getting comfortable with the PRISM software, being able to create
models, run simulations and experiments using the software.

Since the purpose of the Q'Grady language and compiler is to create PRISM
models, the use of PRISM is a necessity as part of the testing and validation of
the compiler. There is a requirement for a work-flow to allow for making this
easier.
% Need to expand.
% subsection prism (end)

\subsection{Java 8}
\label{sub:java_eight}
The compiler for the Q'Grady language will be written in Java. Java was chosen
primarily due to it being the language I am comfortable with, meaning that less
time will be spent looking for solutions to more trivial problems such as
dependency management.

While a language such as C/C++ may seem more appropriate for a compiler, since
the requirements of the compiler are to create PRISM models rather than
executable programs, I felt that there was no need to deal with aspects such as
memory management, while Java would allow me to design the compiler system
without worrying about getting used to a new environment.

In addition, the use of Java allows me to use libraries and tools that I am
already comfortable with, making the development easier.
% subsection java_eight (end)

\subsubsection{JUnit}
\label{sub:junit}
JUnit will be used as part of the testing strategy of the compiler. It will help
test features of the compiler such as the syntax checker, or the algorithm used
to ensure that the user's created non-local box is non-signalling.
% subsection junit (end)

\subsubsection{Apache Maven}
\label{sub:maven}
Maven will assist in the building process of the compiler, allowing for 
automated JUnit testing and dependency management. This will help increase the
efficiency of the development process, in addition to handling any transitive
dependencies that are required as part of the development.
% subsection maven (end)

\subsubsection{Apache Commons CLI}
\label{sub:commons_cli}
The Apache Commons CLI library allows for easier handling of command arguments
for the compiler. As a compiler, there is naturally a requirement for an input
Q'Grady file as well as an optional destination for the PRISM file created, in
addition to any other flags that are thought of to be helpful. 

The Commons CLI library can handle all the logic behind the parsing of the
user's arguments, ensuring that the required arguments are present, and handling
mutually exclusive flags as well.
% subsection commons_cli (end)

% section technologies_to_be_used (end)

\section{Development Process} % (fold)
\label{sec:development_process}
In the `Project Scope and Outline Plan' submission, I had stated that I would
be taking an `incremental and iterative development', noting that a methodology
such as Agile did not seem appropriate at the time. Since then, I have attended
seminars hosted by Amazon and Baillie Gifford, and I do now think that there
are advantages to Agile I can take advantage of when developing the compiler.

The testing of the compiler should be done concurrently with the development of
the compiler, which means that I should in theory have more time for
experimentation if I am not trying to spend time at the end testing.

Scrums followed by supervisor meetings can help ensure that I am meeting the
specification of the project, so I am going astray with each new build, it will
be caught quicker.
% section development_process (end)

\section{Evaluation} % (fold)
\label{sec:evaluation}
One part of evaluation is analysing the models created by Q'Grady. Running
experiments and simulations using the models will assist in determining how
useful Q'Grady is. The complexity of models created is another factor, the more
complex boxes can be set-up would result in more interesting experiments and
results to be obtained. The user friendliness of the language and compiler
should also be considered.
% section evaluation (end)

\section{Risks} % (fold)
\label{sec:risks}
The major risk is related to the understanding of the quantum theory. If my 
comprehension of the non-local boxes' set-ups or the criteria of non-signalling
are not correct, then the resulting language and compiler's usefulness is
thoroughly depleted.

Since this is the first time I have created my own language, then there will be
risks related to the cleanliness or readability of the language that is defined.
It is unlikely that it will be perfect right off the bat, but the better the
understanding of the theory, the easier the language will be to create.

When it comes to the development of the compiler, the primary risk will be
ensuring that I allow for sufficient time for testing and experimentation using
the PRISM models created by the compiler. THis is in addition to the continuous
report writing that must be done in addition to the development (and other
stages).
% section risks (end)
\end{document}